version: 2.1

jobs:
  build:
    docker:
      - image: docker:stable  # Based on Alpine, lightweight

    steps:
      - checkout

      - setup_remote_docker

      - run:
          name: Install curl and Docker Compose V2 plugin
          command: |
            apk add --no-cache curl
            mkdir -p ~/.docker/cli-plugins/
            curl -SL https://github.com/docker/compose/releases/download/v2.24.6/docker-compose-linux-x86_64 -o ~/.docker/cli-plugins/docker-compose
            chmod +x ~/.docker/cli-plugins/docker-compose
            docker compose version


      - run:
          name: Clean up any leftover volumes and containers
          command: |
            # Clean up any leftover containers/volumes from previous runs
            docker compose down -v || true
            docker volume prune -f || true
            # Verify volumes are removed
            docker volume ls | grep -q "project_db" && echo "WARNING: project_db volume still exists" || echo "✓ All volumes cleaned up"

      - run:
          name: Verify init script exists and is valid
          command: |
            echo "Checking init_db.sh file..."
            pwd
            ls -la db/scripts/ || exit 1
            ls -la db/scripts/init_db.sh || exit 1
            if [ ! -f db/scripts/init_db.sh ]; then
              echo "ERROR: init_db.sh is not a regular file!"
              exit 1
            fi
            if [ -d db/scripts/init_db.sh ]; then
              echo "ERROR: init_db.sh exists as a directory instead of a file!"
              exit 1
            fi
            file db/scripts/init_db.sh
            # Ensure file has Unix line endings and proper permissions
            sed -i 's/\r$//' db/scripts/init_db.sh || true
            chmod +x db/scripts/init_db.sh
            # Verify it's still a file after processing
            if [ ! -f db/scripts/init_db.sh ]; then
              echo "ERROR: init_db.sh became invalid after processing!"
              exit 1
            fi
            echo "✓ init_db.sh verified"

      - run:
          name: Pull and build images
          command: |
            docker compose pull postgresdb
            docker compose build app
          no_output_timeout: 10m

      - run:
          name: Start services
          command: |
            docker compose up -d || {
              echo "=== Docker Compose failed to start, showing logs ==="
              docker compose logs
              docker compose ps -a
              # Check if init script was mounted correctly
              if docker compose ps postgresdb | grep -q "Up"; then
                echo "=== Checking mounted init script ==="
                docker compose exec -T postgresdb ls -la /docker-entrypoint-initdb.d/ || true
                docker compose exec -T postgresdb file /docker-entrypoint-initdb.d/init_db.sh || true
              fi
              exit 1
            }

      - run:
          name: Show postgresdb logs in background
          background: true
          command: |
            docker compose logs -f postgresdb

      - run:
          name: Wait for postgresdb to be healthy
          command: |
            echo "Waiting for 'postgresdb' to be healthy..."
            timeout=180
            while [ "$timeout" -gt 0 ]; do
              cid=$(docker compose ps -q postgresdb)
              status=$(docker inspect --format='{{.State.Health.Status}}' "$cid")
              echo "Health status: $status"
              if [ "$status" = "healthy" ]; then
                echo "Postgres is healthy!"
                break
              fi
              sleep 2
              timeout=$((timeout - 2))
            done

            if [ "$timeout" -le 0 ]; then
              echo "Postgres healthcheck timed out"
              echo "=== Showing all logs ==="
              docker compose logs
              echo "=== Showing postgresdb only ==="
              docker compose logs postgresdb
              echo "=== Container status ==="
              docker compose ps -a
              echo "=== Checking postgresdb health ==="
              cid=$(docker compose ps -q postgresdb)
              docker inspect "$cid" | grep -A 5 Health || echo "No health status found"
              exit 1
            fi

      - run:
          name: Run tests in /app
          command: docker compose exec app sh -c "cd /app && mkdir -p test-results && npm test"
          when: always

      - run:
          name: Copy test results from container
          when: always
          command: |
            docker compose cp app:/app/test-results ./test-results || mkdir -p test-results

      - run:
          name: Copy coverage from container
          when: always
          command: |
            docker compose cp app:/app/coverage ./coverage || true

      - store_test_results:
          path: test-results

      - store_artifacts:
          path: coverage
          destination: test-coverage

      - run:
          name: Capture database logs before teardown
          when: always
          command: |
            docker compose logs postgresdb > postgresdb.log || true

      - store_artifacts:
          path: postgresdb.log
          destination: database-logs

      - run:
          name: Teardown
          when: always
          command: |
            # Stop containers gracefully and remove volumes to prevent database corruption
            docker compose stop || true
            sleep 2  # Give PostgreSQL time to shut down cleanly
            docker compose down -v || true
            

workflows:
  version: 2
  build_and_test:
    jobs:
      - build
