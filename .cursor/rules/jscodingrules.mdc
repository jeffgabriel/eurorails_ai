---
description: 
globs: 
alwaysApply: true
---
Here are our unified coding principles for the JavaScript/TypeScript codebase:

1. **Module System**
- Use ES Modules (`import`/`export`) consistently across all code
- Never mix with CommonJS (`require`/`module.exports`)
```typescript
// ‚úÖ Do:
import { Something } from './something';
export class MyClass {}

// ‚ùå Don't:
const something = require('./something');
module.exports = MyClass;
```

2. **TypeScript Configuration**
- Keep `strict: true` in tsconfig.json
- Use explicit type annotations for function parameters and returns
- Allow implicit types for variables when type can be inferred
```typescript
// ‚úÖ Do:
function add(a: number, b: number): number {
  const result = a + b; // type inferred
  return result;
}

// ‚ùå Don't:
function add(a, b) {
  return a + b;
}
```

3. **Testing Setup**
- Use Jest with TypeScript via `ts-jest`
- Keep test files in `__tests__` directories
- Use `.test.ts` extension for test files
- Mock external dependencies explicitly
```typescript
// ‚úÖ Do:
import { MyService } from '../services';
jest.mock('../services');

// ‚ùå Don't:
const MyService = jest.requireActual('../services');
```

4. **File Organization**
```
src/
  client/
    __tests__/        # Client-side tests
    components/
    scenes/
  server/
    __tests__/        # Server-side tests
    routes/
    services/
```

5. **Jest Configuration**
```typescript
{
  preset: 'ts-jest',
  testEnvironment: 'node',
  projects: [
    {
      displayName: 'server',
      testMatch: ['<rootDir>/src/server/__tests__/**/*.test.ts'],
      moduleFileExtensions: ['ts', 'js'],
      transform: {
        '^.+\\.ts$': 'ts-jest'
      }
    },
    {
      displayName: 'client',
      testMatch: ['<rootDir>/src/client/__tests__/**/*.test.ts'],
      testEnvironment: 'jsdom',
      setupFilesAfterEnv: ['<rootDir>/src/client/__tests__/setupTests.ts']
    }
  ]
}
```

6. **Test File Structure**
```typescript
import { Something } from '../path';

// Mock setup at top of file
jest.mock('../path/to/dependency');

describe('Component/Feature name', () => {
  let instance: Something;
  
  beforeEach(() => {
    instance = new Something();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should do something', () => {
    // Arrange
    const input = 'test';
    
    // Act
    const result = instance.doSomething(input);
    
    // Assert
    expect(result).toBe('expected');
  });
});
```

7. **Error Handling**
- Use typed errors
- Always catch and handle errors appropriately
- Provide meaningful error messages
```typescript
// ‚úÖ Do:
try {
  await service.doSomething();
} catch (error) {
  if (error instanceof ServiceError) {
    // Handle specific error
  }
  throw error;
}

// ‚ùå Don't:
try {
  await service.doSomething();
} catch (e) {
  console.log(e);
}
```

8. **Async Code**
- Use async/await over raw promises
- Handle promise rejections
- Maintain proper error propagation
```typescript
// ‚úÖ Do:
async function getData(): Promise<Data> {
  const result = await fetch('/api/data');
  return result.json();
}

// ‚ùå Don't:
function getData() {
  return fetch('/api/data')
    .then(res => res.json());
}
```

9. **Enum Guidelines**
- Use unique enum names across the entire codebase
- Never create enums with overlapping purposes (e.g., CityType vs TerrainType for cities)
- Document enum values with JSDoc comments
- Use PascalCase for enum names and values
- Prefix enum names with domain/category if needed to avoid conflicts
```typescript
// ‚úÖ Do:
/** Represents all terrain types including cities */
export enum TerrainType {
  Clear = 0,
  Mountain = 1,
  MajorCity = 2,
  // ...
}

// ‚ùå Don't:
export enum TerrainType { /* ... */ }
export enum CityType { /* ... */ }  // Overlapping purpose

// ‚ùå Don't: Ambiguous naming
export enum Type { /* ... */ }
```

10. **Enum Value Management**
- Keep a central registry of all enum values to prevent duplicates
- Use numeric values explicitly to catch duplicate values at compile time
- Never mix string and numeric enum values within the same enum
```typescript
// ‚úÖ Do:
export enum TerrainType {
  Clear = 0,
  Mountain = 1,
  MajorCity = 2
}

// ‚ùå Don't: Mixed value types
export enum TerrainType {
  Clear = 0,
  Mountain = "MOUNTAIN",
  MajorCity = 2
}

// ‚ùå Don't: Implicit values that could clash
export enum TerrainType {
  Clear,      // 0
  Mountain,   // 1
  MajorCity   // 2
}
```

# Type Changes Rule

When modifying types in the codebase:

1. Always check existing type definitions first before creating new ones
2. Only modify types when there is a clear requirement to do so such as missing property which must now go on the type or for design reasons you have been instructed to make a type change by the prompt.
3. When adding new functionality that uses existing types:
   - First try to use the existing type structure
   - Only extend types if the new functionality cannot be expressed with existing types
   - Document why the type extension is necessary
4. Never consolidate or split types without explicit requirements
5. When in doubt, ask for clarification before making type changes

# ‚öôÔ∏è TypeScript Game Architecture Guide for Coding Agent

## üåü Purpose

This guide outlines architectural principles and patterns for building a maintainable, scalable, and performant game in TypeScript. The target game uses a hex/grid map, track building, object manipulation, and turn-based player logic.

---

## üì¶ Core Architectural Principles

### 1. **Model Domain Objects as Classes or Interfaces**

* Every core game concept (e.g., `Train`, `City`, `LoadChip`, `TrackSegment`) should be a distinct class or interface.
* Encapsulate data and methods within each object:

  ```ts
  class Train {
    type: TrainType;
    position: GridPoint;
    draw(): void;
    move(path: GridPoint[]): void;
  }
  ```

---

### 2. **Separate Game Logic from Rendering**

* Keep rendering code in `View` or `Sprite` classes.
* Logic classes (`Train`, `Track`, `GameState`) **must not access rendering APIs** (e.g., Phaser).
* Use composition:

  ```ts
  class TrainView {
    constructor(public train: Train, public graphics: Graphics) {}
    draw(): void { ... }
  }
  ```

---

### 3. **Centralized Game State**

* Use a single `GameState` structure to manage game data:

  ```ts
  interface GameState {
    players: Player[];
    trains: Record<string, Train>;
    board: GridMap;
    currentPlayerId: string;
    turnPhase: TurnPhase;
  }
  ```

---

### 4. **Strong Typing & Enum Modeling**

* Use `type` aliases and `enum`s for clear expression of rules and constraints:

  ```ts
  type TrainType = 'Freight' | 'FastFreight' | 'HeavyFreight' | 'Superfreight';
  enum TerrainType { Clear, Mountain, Alpine, River, Ocean }
  ```

---

### 5. **Use Grid Utilities for Map Logic**

* Movement and neighbor logic should be encapsulated in a `Grid` class:

  ```ts
  class HexGrid {
    getNeighbors(point: GridPoint): GridPoint[];
    distance(a: GridPoint, b: GridPoint): number;
  }
  ```

---

## üß† Behavioral Modeling

### 6. **Use State Machines for Turn Phases**

* Each player‚Äôs turn follows a strict sequence:

  * Move train
  * Load/unload
  * Deliver
  * Build/upgrade
* Represent this using a state machine or turn-phase enum.

---

### 7. **Encapsulate Drawing Behavior per Object Type**

* Prefer putting drawing logic inside each model or associate it closely with it:

  * `Train.draw(graphics)`
  * `City.draw()`
  * Avoid large procedural rendering functions.

---

### 8. **Event-Driven Updates**

* Use an event bus or observer pattern to signal game state changes:

  ```ts
  eventBus.emit('loadPickedUp', { trainId, loadType });
  ```

---

### 9. **Avoid Global State Outside Game Context**

* Do not rely on global variables.
* Use dependency injection for services such as sound, rendering layers, or network.

---

## üß™ Testability and Maintainability

### 10. **Pure Logic Should Be Easily Unit-Tested**

* Ensure pathfinding, rule enforcement, and game rules are testable without graphics or UI.

### 11. **Use Factory Functions for Complex Creation**

* Example: `createTrain(trainType: TrainType, startPoint: GridPoint): Train`

---

## üõ†Ô∏è Suggested Folder Structure

```
/models        # Domain logic (Train, City, Load, Track)
/views         # Rendering code and sprite helpers
/state         # Game state container and reducers
/utils         # Grid math, helpers
/engine        # Turn manager, event dispatcher, AI agent
/config        # Static data (terrain costs, load types)
```

---

## üìå Summary Checklist

| ‚úÖ Best Practice               | üí¨ Summary                                     |
| ----------------------------- | ---------------------------------------------- |
| Domain models encapsulated    | `Train`, `City`, `Load` are self-contained     |
| Rendering isolated from logic | Views handle Phaser; logic is UI-agnostic      |
| Global state centralized      | Use `GameState` or reducer pattern             |
| Typed enums for logic safety  | Use `enum` and `type` aliases                  |
| Grid logic abstracted         | `HexGrid.getNeighbors`, `GridUtils.snapToGrid` |
| Events not direct callbacks   | Use event bus for gameplay updates             |
| Turn sequence enforceable     | Represented explicitly via state machine       |
| View class per game object    | Avoid centralized `drawAll` logic              |
| Test coverage on pure logic   | Model rules testable in isolation              |
